/**
 * Xflow AI Hackathon 2026 - Rendering Engines
 * 
 * ASCIIOnlyEngine: Pure ASCII rendering for hero section
 * ThreeJSEngine: 3D + ASCII hover reveal for content sections
 */

// ===== ASCII ONLY ENGINE (Hero Section) =====
class ASCIIOnlyEngine {
    constructor(canvasId, modelPath) {
        this.canvas = document.getElementById(canvasId);
        this.modelPath = modelPath;

        // Mouse tracking
        this.mouseX = 0;
        this.mouseY = 0;
        this.targetRotationX = 0;
        this.targetRotationY = 0;

        // ASCII Settings (High Resolution)
        this.charWidth = 3.6;
        this.charHeight = 6;
        // this.asciiChars = ".₹$€£";
        this.asciiChars = "£€$₹..";


        // Performance
        this.frameCount = 0;
        this.asciiUpdateInterval = 2; // Update ASCII every N frames

        // Initialize
        this.initASCIIHelpers();
        this.initThreeJS();
        this.initEventListeners();
        this.loadModel();
        this.animate();
    }

    initASCIIHelpers() {
        this.smallCanvas = document.createElement('canvas');
        this.smallCtx = this.smallCanvas.getContext('2d', { willReadFrequently: true });
        this.updateASCIIDimensions();
    }

    updateASCIIDimensions() {
        const cols = Math.floor(window.innerWidth / this.charWidth);
        const rows = Math.floor(window.innerHeight / this.charHeight);

        this.smallCanvas.width = cols;
        this.smallCanvas.height = rows;
        this.cols = cols;
        this.rows = rows;
    }

    initThreeJS() {
        // Offscreen renderer (not visible)
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCanvas.width = window.innerWidth;
        this.offscreenCanvas.height = window.innerHeight;

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1F2741);

        const aspect = window.innerWidth / window.innerHeight;
        this.camera = new THREE.PerspectiveCamera(35, aspect, 0.1, 1000);
        this.camera.position.z = 15;

        this.renderer = new THREE.WebGLRenderer({
            canvas: this.offscreenCanvas,
            antialias: true,
            preserveDrawingBuffer: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
        keyLight.position.set(1, 1, 2).normalize();
        this.scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0xeef4ff, 0.5);
        fillLight.position.set(-1, -1, 1).normalize();
        this.scene.add(fillLight);

        this.modelGroup = new THREE.Group();
        this.scene.add(this.modelGroup);
    }

    loadModel() {
        if (typeof THREE.OBJLoader === 'undefined') {
            console.warn('OBJLoader not available');
            return;
        }

        const loader = new THREE.OBJLoader();

        loader.load(
            this.modelPath,
            (object) => {
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    shininess: 60,
                    flatShading: false,
                    side: THREE.DoubleSide
                });

                object.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });

                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 4 / maxDim;

                object.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
                object.scale.setScalar(scale);

                this.modelGroup.add(object);
                this.model = object;
            },
            (xhr) => { },
            (error) => {
                console.error('Error loading model:', error);
            }
        );
    }

    initEventListeners() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.offscreenCanvas.width = window.innerWidth;
            this.offscreenCanvas.height = window.innerHeight;
            this.updateASCIIDimensions();
        });


        // Only track mouse when over hero section
        const heroSection = document.querySelector('.hero-section');
        if (heroSection) {
            heroSection.addEventListener('mousemove', (e) => {
                const rect = heroSection.getBoundingClientRect();
                this.mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouseY = ((e.clientY - rect.top) / rect.height) * 2 - 1;

                const maxTilt = 0.5;
                this.targetRotationY = this.mouseX * maxTilt;
                this.targetRotationX = this.mouseY * maxTilt * 0.5;
            });

            heroSection.addEventListener('mouseleave', () => {
                this.targetRotationY = 0;
                this.targetRotationX = 0;
            });
        }
    }

    renderASCII() {
        if (!this.model) return;

        // Throttle ASCII generation for performance
        if (this.frameCount % this.asciiUpdateInterval !== 0) {
            return;
        }

        this.smallCtx.drawImage(this.offscreenCanvas, 0, 0, this.cols, this.rows);
        const imageData = this.smallCtx.getImageData(0, 0, this.cols, this.rows);
        const data = imageData.data;

        let asciiStr = "";

        for (let i = 0; i < this.cols * this.rows; i++) {
            const r = data[i * 4];
            const g = data[i * 4 + 1];
            const b = data[i * 4 + 2];

            const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            const charIndex = Math.floor((1.0 - brightness) * (this.asciiChars.length - 1));
            const char = this.asciiChars[charIndex];

            asciiStr += char;

            if ((i + 1) % this.cols === 0) {
                asciiStr += "\n";
            }
        }

        this.canvas.innerText = asciiStr;
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        if (this.modelGroup) {
            this.modelGroup.rotation.y += (this.targetRotationY - this.modelGroup.rotation.y) * 0.1;
            this.modelGroup.rotation.x += (this.targetRotationX - this.modelGroup.rotation.x) * 0.1;
        }

        this.renderer.render(this.scene, this.camera);
        this.renderASCII();
        this.frameCount++;
    }
}

// ===== THREE.JS ENGINE (Content Sections) =====
class ThreeJSEngine {
    constructor(sectionId, modelPath) {
        this.sectionId = sectionId;
        this.pixelCanvas = document.getElementById(`pixel-canvas-${sectionId}`);
        this.asciiCanvas = document.getElementById(`ascii-canvas-${sectionId}`);
        this.container = document.getElementById(`canvas-container-${sectionId}`);

        // Mouse tracking
        this.mouseX = 0;
        this.mouseY = 0;
        this.targetRotationX = 0;
        this.targetRotationY = 0;

        // Mask position (Start off-screen)
        this.maskX = -1;
        this.maskY = -1;
        this.targetMaskX = -1;
        this.targetMaskY = -1;

        // ASCII Settings (Optimized)
        this.charWidth = 8;  // Increased for performance
        this.charHeight = 12;
        this.asciiChars = ".₹$€£";

        // Performance
        this.frameCount = 0;
        this.asciiUpdateInterval = 3; // Update ASCII every N frames
        this.isVisible = false; // Only render when visible

        // Initialize
        this.initASCIIHelpers();
        this.initThreeJS();
        this.initEventListeners();
        this.setupObserver(); // New observer
        this.loadModel(modelPath);
        this.animate();
    }

    initASCIIHelpers() {
        this.smallCanvas = document.createElement('canvas');
        this.smallCtx = this.smallCanvas.getContext('2d', { willReadFrequently: true });

        const cols = Math.floor(590 / this.charWidth);
        const rows = Math.floor(642 / this.charHeight);

        this.smallCanvas.width = cols;
        this.smallCanvas.height = rows;
        this.cols = cols;
        this.rows = rows;
    }

    initThreeJS() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x818BAF);

        const aspect = 590 / 642;
        this.camera = new THREE.PerspectiveCamera(35, aspect, 0.1, 1000);
        this.camera.position.z = 15;

        this.renderer = new THREE.WebGLRenderer({
            canvas: this.pixelCanvas,
            antialias: true,
            alpha: false,
            preserveDrawingBuffer: true
        });
        this.renderer.setSize(590, 642);
        this.renderer.setPixelRatio(window.devicePixelRatio);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
        keyLight.position.set(1, 1, 2).normalize();
        this.scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0xeef4ff, 0.5);
        fillLight.position.set(-1, -1, 1).normalize();
        this.scene.add(fillLight);

        this.modelGroup = new THREE.Group();
        this.scene.add(this.modelGroup);
    }

    loadModel(modelPath) {
        if (typeof THREE.OBJLoader === 'undefined') {
            console.warn('OBJLoader not available');
            return;
        }

        const loader = new THREE.OBJLoader();

        loader.load(
            modelPath,
            (object) => {
                const material = new THREE.MeshPhongMaterial({
                    color: 0x2E5CB8,
                    shininess: 60,
                    flatShading: false,
                    side: THREE.DoubleSide
                });

                object.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });

                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 4 / maxDim;

                object.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
                object.scale.setScalar(scale);

                this.modelGroup.add(object);
                this.model = object;
            },
            (xhr) => { },
            (error) => {
                console.error('Error loading model:', error);
            }
        );
    }

    initEventListeners() {
        this.container.addEventListener('mousemove', (e) => {
            const rect = this.container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            this.mouseX = (x / rect.width) * 2 - 1;
            this.mouseY = (y / rect.height) * 2 - 1;

            const maxTilt = 0.5;
            this.targetRotationY = this.mouseX * maxTilt;
            this.targetRotationX = this.mouseY * maxTilt * 0.5;

            this.targetMaskX = x / rect.width;
            this.targetMaskY = y / rect.height;
        });
    }

    setupObserver() {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                this.isVisible = entry.isIntersecting;
            });
        }, { threshold: 0.1 }); // 10% visible

        observer.observe(this.container);
    }

    renderASCII() {
        if (!this.model) return;

        // Throttle ASCII generation for performance
        if (this.frameCount % this.asciiUpdateInterval !== 0) {
            return;
        }

        this.smallCtx.drawImage(this.pixelCanvas, 0, 0, this.cols, this.rows);
        const imageData = this.smallCtx.getImageData(0, 0, this.cols, this.rows);
        const data = imageData.data;

        let asciiStr = "";

        for (let i = 0; i < this.cols * this.rows; i++) {
            const r = data[i * 4];
            const g = data[i * 4 + 1];
            const b = data[i * 4 + 2];

            const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            const charIndex = Math.floor((1.0 - brightness) * (this.asciiChars.length - 1));
            const char = this.asciiChars[charIndex];

            asciiStr += char;

            if ((i + 1) % this.cols === 0) {
                asciiStr += "\n";
            }
        }

        this.asciiCanvas.innerText = asciiStr;
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        // Only render if visible
        if (!this.isVisible) return;

        if (this.modelGroup) {
            this.modelGroup.rotation.y += (this.targetRotationY - this.modelGroup.rotation.y) * 0.1;
            this.modelGroup.rotation.x += (this.targetRotationX - this.modelGroup.rotation.x) * 0.1;
        }

        const maskEasing = 0.2;
        this.maskX += (this.targetMaskX - this.maskX) * maskEasing;
        this.maskY += (this.targetMaskY - this.maskY) * maskEasing;

        this.container.style.setProperty('--mask-x', `${this.maskX * 100}%`);
        this.container.style.setProperty('--mask-y', `${this.maskY * 100}%`);

        this.renderer.render(this.scene, this.camera);
        this.renderASCII();
        this.frameCount++;
    }
}
